\begin{code}

module Examples.SelectiveReceive where

open import ActorMonad public
open import Data.List using (List ; _∷_ ; [] ; _++_)
open import Data.List.All using (All ; _∷_ ; [])
open import Data.List.Properties using (++-assoc ; ++-identityʳ)
open import Data.Bool using (Bool ; false ; true)
open import Data.Nat using (ℕ ; zero ; suc)
open import Level using (Level ; Lift ; lift)
            renaming (zero to lzero ; suc to lsuc)
open import Size using (Size ; ↑_)
open import Data.List.Any using (here ; there)
open import Relation.Binary.PropositionalEquality
            using (_≡_ ; refl ; cong ; sym ; inspect ; [_] ; trans)
open import Membership
open import Data.Unit using (⊤ ; tt)


waiting-refs : ∀ {IS} → (q : List (Message IS)) → ReferenceTypes
waiting-refs [] = []
waiting-refs (x ∷ q) = add-references (waiting-refs q) x

record SplitList {a : Level} {A : Set a} (ls : List A) : Set (lsuc a) where
  field
    heads : List A
    el : A
    tails : List A
    is-ls : (heads) ++ (el ∷ tails) ≡ ls

data FoundInList {a : Level} {A : Set a}
                 (ls : List A) (f : A → Bool) : Set (lsuc a) where
  Found : (split : SplitList ls) →
          (f (SplitList.el split) ≡ true) →
          FoundInList ls f
  Nothing : FoundInList ls f

find-split : {a : Level} {A : Set a}
             (ls : List A) (f : A → Bool) →
             FoundInList ls f
find-split [] f = Nothing
find-split (x ∷ ls) f with (f x) | (inspect f x)
... | false | p = add-x (find-split ls f)
  where
    add-x : FoundInList ls f → FoundInList (x ∷ ls) f
    add-x (Found split el-is-ok) = Found (record {
      heads = x ∷ heads split
      ; el = el split
      ; tails = tails split
      ; is-ls = cong (_∷_ x) (is-ls split)
      }) el-is-ok
      where open SplitList
    add-x Nothing = Nothing
... | true | [ eq ] = Found (record {
      heads = []
      ; el = x
      ; tails = ls
      ; is-ls = refl
      }) eq

add-references++ : ∀ {IS} → (xs ys : ReferenceTypes) →
                   (x : Message IS) →
                     add-references (xs ++ ys) x ≡
                     add-references xs x ++ ys
add-references++ xs ys (Msg {MT} x x₁) =
                 sym (++-assoc (extract-references MT) xs ys)

waiting-refs++ : ∀ {IS} → (xs ys : List (Message IS)) →
                        waiting-refs (xs ++ ys) ≡
                        waiting-refs xs ++ waiting-refs ys
waiting-refs++ [] _ = refl
waiting-refs++ (x ∷ xs) ys with (waiting-refs++ xs ys)
... | q with (cong (λ qs → add-references qs x) q)
... | r = trans r (halp xs ys x)
  where
    halp : ∀ {IS} → (xs ys : List (Message IS)) (x : Message IS) →
      add-references (waiting-refs xs ++ waiting-refs ys) x ≡
      add-references (waiting-refs xs) x ++ waiting-refs ys
    halp xs ys x = add-references++ (waiting-refs xs) (waiting-refs ys) x

move-received : ∀ {IS} → ∀ pre →
                (q : List (Message IS)) →
                (x : Message IS) →
                  (pre ++ (waiting-refs (q ++ (x ∷ [])))) ⊆
                  (add-references (pre ++ waiting-refs q) x)
move-received pre q (Msg {MT} x x₁) rewrite
                    (waiting-refs++ q (Msg x x₁ ∷ [])) |
                    (++-identityʳ (extract-references MT)) =
                    ⊆-trans move-1 move-2
  where
    move-1 : (pre ++ waiting-refs q ++ extract-references MT) ⊆
             ((pre ++ waiting-refs q) ++ extract-references MT)
    move-1 = ⊆++comm' pre (waiting-refs q) (extract-references MT)
    move-2 : ((pre ++ waiting-refs q) ++ extract-references MT) ⊆
             (extract-references MT ++ (pre ++ waiting-refs q))
    move-2 = ⊆-move (pre ++ waiting-refs q) (extract-references MT)

accept-received : ∀ {IS} → ∀ pre →
                  (q : List (Message IS)) →
                  (x : Message IS) →
                    (add-references pre x ++ waiting-refs q) ⊆
                    (add-references (pre ++ waiting-refs q) x)
accept-received pre q (Msg {MT} x x₁) = ⊆++comm
                                        (extract-references MT)
                                        pre
                                        (waiting-refs q)

open SplitList


accept-found : ∀ {IS} → ∀ Γ →
               (q : List (Message IS)) →
               (split : SplitList q) →
                 (add-references Γ (el split) ++
                   waiting-refs (heads split ++ tails split)) ⊆
                 (Γ ++ waiting-refs q)
accept-found Γ q record {
  heads = heads
  ; el = Msg {MT} x y
  ; tails = tails
  ; is-ls = is-ls
  } rewrite (sym is-ls) =
  ⊆-trans
    (⊆-inc
      (extract-references MT ++ Γ)
      (Γ ++ extract-references MT)
      (waiting-refs (heads ++ tails))
      (⊆-move (extract-references MT) Γ)
    )
    (⊆-trans
      (⊆++comm
        Γ
        (extract-references MT)
        (waiting-refs (heads ++ tails))
      )
      (⊆-skip
        Γ
        (extract-references MT ++ waiting-refs (heads ++ tails))
        (waiting-refs (heads ++ Msg x y ∷ tails))
        final-move
      )
    )
  where
    final-move : (extract-references MT ++ waiting-refs (heads ++ tails)) ⊆
                 waiting-refs (heads ++ Msg x y ∷ tails)
    final-move rewrite
      (waiting-refs++ heads tails) |
      (waiting-refs++ heads (Msg x y ∷ tails)) =
      ⊆-trans
        (⊆++comm'
          (extract-references MT)
          (waiting-refs heads)
          (waiting-refs tails)
        )
        (⊆-trans
          (⊆-inc
            (extract-references MT ++ waiting-refs heads)
            (waiting-refs heads ++ extract-references MT)
            (waiting-refs tails)
            (⊆-move (extract-references MT) (waiting-refs heads))
          )
          (⊆++comm
            (waiting-refs heads)
            (extract-references MT)
            (waiting-refs tails)
          )
        )

MessageFilter : (IS : InboxShape) → Set₁
MessageFilter IS = Message IS → Bool
\end{code}
%<*SelRec>
\begin{code}
record SelRec (IS : InboxShape) (f : MessageFilter IS) : Set₁ where
  field
    msg : Message IS
    msg-ok : f msg ≡ true
    waiting : List (Message IS)
\end{code}
%</SelRec>
\begin{code}
open SelRec
\end{code}
%<*selective-receive>
\begin{code}
selective-receive : ∀ {i IS Γ} →
                      (q : List (Message IS)) →
                      (f : MessageFilter IS) →
                      ∞ActorM i IS
                        (SelRec IS f)
                        (Γ ++ (waiting-refs q))
                        (λ m → add-references Γ (msg m) ++
                               waiting-refs (waiting m))
\end{code}
%</selective-receive>
\begin{code}
selective-receive {IS = IS} {Γ} q f = case-of-find (find-split q f)
  where
    case-of-find : ∀ {i} →
                     FoundInList q f →
                     ∞ActorM i IS
                       (SelRec IS f)
                       (Γ ++ waiting-refs q)
                       (λ m → add-references Γ (msg m) ++
                              waiting-refs (waiting m))
    case-of-find (Found split x) .force =
      strengthen (accept-found Γ q split) ∞>>
      return₁ (record {
        msg = el split
        ; msg-ok = x
        ; waiting = (heads split) ++ (tails split)
        })
    case-of-find Nothing .force =
      receive ∞>>=
      handle-receive
      where
        handle-receive : ∀ {i}
                           (x : Message IS) →
                           ∞ActorM i IS
                             (SelRec IS f)
                             (add-references (Γ ++ waiting-refs q) x)
                             (λ m → add-references Γ (msg m) ++
                                    waiting-refs (waiting m))
        handle-receive x with (f x) | (inspect f x)
        handle-receive {i} x  | false | p =
          strengthen (move-received Γ q x) >>
          selective-receive (q ++ (x ∷ [])) f
        handle-receive x | true | [ p ] =
          strengthen (accept-received Γ q x) >>
          return₁ ret-v
          where
            ret-v : SelRec IS f
            ret-v = record { msg = x ; msg-ok = p ; waiting = q }
\end{code}

\begin{code}
SelectiveTestBox : InboxShape
SelectiveTestBox = (ValueType Bool ∷ []) ∷ []

testActor : ∀ {i} → ActorM i SelectiveTestBox (Lift Bool) [] (λ _ → [])
testActor = selective-receive [] only-true ∞>>= after-receive
  where
    only-true : Message SelectiveTestBox → Bool
    only-true (Msg Z (b ∷ [])) = b
    only-true (Msg (S ()) x₁)
    after-receive : ∀ {i}
                    (x : SelRec SelectiveTestBox only-true) →
                    ∞ActorM i SelectiveTestBox (Lift Bool)
                      (add-references [] (msg x) ++ waiting-refs (waiting x))
                      (λ _ → [])
    after-receive record { msg = (Msg Z (.true ∷ [])) ; msg-ok = refl } =
      strengthen [] >>
      return true
    after-receive record { msg = (Msg (S ()) _) }

spawner : ∀ {i} → ActorM i [] ⊤₁ [] (λ _ → [])
spawner =
  spawn testActor ∞>>
  ((Z ![t: Z ] ((lift false) ∷ [])) >>
  strengthen [])
\end{code}
