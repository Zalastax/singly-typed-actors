\begin{code}
module ActorMonad where
open import Membership using (_∈_ ; _⊆_ ; ⊆-refl ; Z ; S ; find-∈)

open import Data.List using (List ; [] ; _∷_ ; _++_)
open import Data.List.All using (All ; [] ; _∷_)
open import Data.Unit using (⊤ ; tt)

open import Coinduction using (∞ ; ♯_)
open import Level using (Lift ; lift ; suc ; zero)
\end{code}

An Actor is indexed by the shape of its inbox.

The shape dictates what types the messages sent to an actor can have,
 and thus also what types the messages being received by the actor can have.

The shape is constant over the actors whole life-time.
It would be nice to allow the shape to grow monotonically over time.
The use of coinduction is a product of wanting to allow actors to have mutual references
 Alternative solutions are welcome

Values and references are kept separate,
since the sending and receiving of values have different behaviour from sending and receiving references.

%<*InboxShape>
Our typing rules for communication are based on the idea that the most important property of a message is that it can be understood by the receiver.
The type system will thus be used to limit what type a message sent to an inbox can have.
By limiting the types of messages sent to an inbox,
we can make sure that every message read from the inbox has the expected type.
In terms of cite!43 years!, this is the interface of the actor.

\AgdaTarget{InboxShape}
\AgdaTarget{ValueType}
\AgdaTarget{ReferenceTypes}
\begin{code}
mutual
  data MessageField : Set₁ where
    ValueType : Set → MessageField
    ReferenceType : InboxShape → MessageField

  MessageType = List MessageField

  InboxShape = List MessageType

  ReferenceTypes = List InboxShape
\end{code}

The \AgdaRef[ActorMonad]{InboxShape} is a variant type that details all the messages that can be received from an inbox.
We can think of the \AgdaRef[ActorMonad]{InboxShape} as a set of types,
and every received message comes paired with a proof that the message is a type from that set.
To know what type the message has you have to inspect the proof,
Agda will solve the constraints, and the value or reference in the message will be accessible.
For those familiar with Haskell, \AgdaRef[ActorMonad]{InboxShape} can be seen as a generalized Either type.
We create two convenient properties expressing that a type is a value or a reference in the mentioned set:
\AgdaTarget{_is-reference-in_}
\begin{code}
-- _is-value-in_ : Set → InboxShape → Set₁
-- V is-value-in S = V ∈ InboxShape.value-types S

-- _is-reference-in_ : InboxShape → InboxShape → Set₁
-- R is-reference-in S = R ∈ InboxShape.reference-types S
\end{code}

A value type is any type from Agda's lowest set universe.
Typical examples are \AgdaRef[Examples/Types]{Bool}, \AgdaRef[Examples/Types]{ℕ}, or \AgdaRef[Examples/Types]{⊤}.
We limit the types to the lowest set universe since it's not clear how values of higher universes could be serialized
and to be sent over the wire in a distributed setting, since that would entail serializing the types themselves.
Unfortunately, the lowest set universe also contain functions that have their types fully specified:
\AgdaCatch{Examples/Types}{unfortunate}
We could of course add further constraints on the types, e.g. that every value has to be serializable,
but due to its insignificance to the calculus we have opted not to.
%</InboxShape>

%<*InboxShapeSubtype>
Before describing references, we will make a side-step to introduce the subtyping rule for \AgdaRef[ActorMonad]{InboxShape}.
This rule will be used to let different components of our system have different interfaces to the same inbox.
Since an actor can only have one inbox, without a subtyping rule, each component would be forced to specify types it never intends to use.
Changes in such system would become overly cumbersome,
since the seemingly small change of letting an actor accept a new type could force changes in the whole system.
This problem of an overly strict type system in combination with the necessary union of types for inboxes is a problem \textcite{DBLP:conf/ecoop/HeWT14} calls the \emph{type pollution problem}.

\textcite{DBLP:conf/ecoop/HeWT14} solves the type pollution problem with subtyping, and so do we.
Given two inboxes $A$ and $B$, if $A <: B$, then every message in $A$ is also a valid message in $B$.
Since we model \AgdaRef[ActorMonad]{InboxShape} as a set,
our subtype relation is of course the proposition that the values types in $A$ are a subset of the value types in $B$,
and the reference types in $A$ are a subset of the references in $B$.

\todo{Create an example of the type-pollution problem solved}
\begin{code}
_<:_ = _⊆_ {A = MessageType}
\end{code}
%</InboxShapeSubtype>

%<*ReferenceSubtype>
With the subtype relation defined we can finally describe references.
% As mentioned, the important property of a message is that it can be understood by the receiver.
% We could also say that the type of the message has to be compatible with the specified type, i.e. the actual type is a subtype of the wanted type.
% Let's focus on what the subtype relation should be for a message containing a reference.
A reference is directly tied to an underlying inbox and what inbox that is can not change during its lifetime.
The type of a reference specifies what type a message sent to it can have,
and is used to uphold the guarantee that every message in the inbox can be understood by the receiver.
Sending an actor a message of the wrong type will raise a compilation error.
By using type-parameterized actor references,
the receiver does not need to worry about unexpected messages,
while senders can be sure that messages will be understood.

For inboxes the subtype relation $A <: B$ says that every message in $A$ is also a valid message in $B$.
It should therefore be possible to downcast a reference of type $B$ to a reference of type $A$,
since every message sent to a reference of type $A$ will be a valid message in $B$.
Actor references should thus be contravariant in its argument \parencite{DBLP:conf/ecoop/HeWT14}.
The notion of a subtype for references is important to implement the pattern of sending a command together with what reference to reply to,
since different actors receiving the reply will have different \AgdaRef[ActorMonad]{InboxShape}.
This pattern, together with a filtering receive construct, can be used to implement synchronous calls \parencite{ericsson_gen}.

To formalize the notion of a reference that can be sent in a message in place of a less demanding type,
we create a variant of the \AgdaRef[ActorMonad]{_is-reference-in_} property.
The new property states that \AgdaSymbol{Fw} is a contravariant subtype to one of the references in \AgdaSymbol{S}.
An actor with \AgdaRef[ActorMonad]{InboxShape} \AgdaSymbol{S} should thus be able to receive a message containing a reference of type \AgdaSymbol{Fw}
and use it as if it was a reference of the type it wanted.

\begin{code}
record compatible-reference (pre : ReferenceTypes) (requested : InboxShape) : Set₁ where
  constructor [_]>:_
  field
    {actual} : InboxShape
    actual-is-sendable : actual ∈ pre
    actual-handles-requested : requested <: actual

\end{code}
%</ReferenceSubtype>
%<*Messages>
\begin{code}

-- We can create a value message for an inbox of shape S,
-- if the type of the value is a value type for S.
-- data ValueMessage (S : InboxShape) : Set₁ where
--  Value : ∀ {A} → A is-value-in S → A → ValueMessage S

-- We can create a reference message for an inbox of shape S,
-- if the type of the reference is a reference type for S.
--
-- When a reference message is received, the actors capabilities will increase,
-- allowing the actor to send messages to the actor referenced by the message.
--
-- A reference message can be created without having a valid reference in the current context.
-- It is the constructors of ActorM (more specifically SendReference) that limits the sending
-- of references to only those that are valid in the current context.
--
-- We index ReferenceMessage by both the reference type and the receiver's inbox.
-- data ReferenceMessage (S Fw : InboxShape) : Set₁ where
--  Reference : Fw is->:-reference-in S → ReferenceMessage S Fw

-- A Message is either a value or a reference.
--
-- We could just have wrapped ValueMessage and ReferenceMessage,
-- but that makes for a noisier experience when pattern matching in application code.

send-field-content : ReferenceTypes → MessageField → Set₁
send-field-content pre (ValueType A) = Lift A
send-field-content pre (ReferenceType requested) = compatible-reference pre requested


data SendMessage (To : InboxShape) (pre : ReferenceTypes) : Set₁ where
  SendM : {MT : MessageType} → MT ∈ To → All (send-field-content pre) MT → SendMessage To pre

receive-field-content : MessageField → Set
receive-field-content (ValueType A) = A
receive-field-content (ReferenceType Fw) = ⊤

data Message (To : InboxShape) : Set₁ where
  Msg : {MT : MessageType} → MT ∈ To → All receive-field-content MT → Message To

\end{code}
%</Messages>
\begin{code}

-- Simple lifting of ⊤ to reduce noise when the monad returns ⊤
⊤₁ : Set₁
⊤₁ = Lift ⊤

extract-references : MessageType → ReferenceTypes
extract-references [] = []
extract-references (ValueType x ∷ mt) = extract-references mt
extract-references (ReferenceType T ∷ mt) = T ∷ extract-references mt

-- When a message is received, we increase our capabilities iff the message is a reference.
add-references : ∀ {To} → ReferenceTypes → Message To → ReferenceTypes
add-references {To} pre (Msg {MT} x x₁) = extract-references MT ++ pre


infixl 1 _>>=_

-- An Actor is modeled as a monad.
--
-- It is indexed by the shape of its inbox, which can't change over the course of its life-time.
--
--
-- 'A' is the return value of the monad.
--
-- 'pre' is the precondition on the list of references that are available.
-- The precondition is what limits an actor to only being able to send messages
-- to actors that it has a reference to.
-- Sending a message is done by indexing into 'es',
-- thereby proving that the actor has a reference to the actor
-- that it's sending the message to.
--
-- 'post' is the postcondition on the list of references.
-- The postcondition sometimes depends on what happens during runtime,
-- and is thus modelled as a function on 'A'.
-- 'post' is what enables receive to have the right type.
data ActorM (IS : InboxShape) : (A : Set₁) →
              (pre : ReferenceTypes) →
              (post : A → ReferenceTypes) →
              Set₂ where
  -- Value is also known as return.
  -- The precondition is the same as the assignment axiom schema in Hoare logic.
  Value : ∀ {A post} → (val : A) → ActorM IS A (post val) post
  -- Bind / composition
  -- This is the same as the rule of composition in Hoare logic.
  -- post₁ is the midcondition.
  _>>=_ : ∀ {A B pre post₁ post₂} → (m : ∞ (ActorM IS A pre post₁)) →
          (f : (x : A) → ∞ (ActorM IS B (post₁ x) (post₂))) →
          ActorM IS B pre post₂
  -- Spawn a new actor.
  -- The spawned actor does not know any references.
  -- The reference to the spawned actor is added to the parent actor.
  Spawn : {NewIS : InboxShape} → {A : Set₁} → ∀ {pre postN} →
          ActorM NewIS A [] postN →
          ActorM IS ⊤₁ pre λ _ → NewIS ∷ pre
  -- Send a value to an actor.
  -- A value can only be sent to an actor if a reference to it is
  -- available in the precondition.
  -- ValueMessage is indexed by the shape of the inbox we're sending to,
  -- which makes sure that it's not possible to send values of the wrong type.
  Send : ∀ {pre} → {ToIS : InboxShape} →
    (canSendTo : ToIS ∈ pre) →
    (msg : SendMessage ToIS pre) →
    ActorM IS ⊤₁ pre (λ _ → pre)
  -- Send a reference to an actor.
  -- A reference can only be sent to an actor if a reference to it is
  -- available in the precondition.
  -- The reference being sent also has to be available in the precondition.
  -- ReferenceMessage is indexed by the shape of both the shape of the forwarded
  -- reference and the shape of the receiving inbox.
  -- SendReference : ∀ {pre} → {ToIS FwIS : InboxShape} →
  --  (canSendTo : ToIS ∈ pre) →
  --  (canForward : FwIS ∈ pre) →
  --  (msg : ReferenceMessage ToIS FwIS) →
  --  ActorM IS ⊤₁ pre (λ _ → pre)
  -- Receive a message.
  -- When receiving a message, the postcondition depends on whether the message
  -- is a value or a reference.
  -- If the message is a value, the postcondition is the same as the precondition.
  -- If the message is a reference, the postcondition is the reference cons'ed to the precondition.
  -- If a receive is encountered when there are no messages in the actor's inbox,
  -- then the actor is moved to the 'blocked queue'.
  -- Sending a message to a blocked actor will move the actor from the 'blocked queue' back to the
  -- active actors.
  Receive : ∀ {pre} → ActorM IS (Message IS) pre (add-references pre)
  -- Lift let's you call a sub-program that needs less references than what is currently available.
  -- To allow that a lifted program increases the available references,
  -- the postcondition of the resulting actor is the same as the postcondition of the lifted program.¨
  -- We'd like there to be a way of re-adding the forgotten references, but that's easy to implement.
  -- To implement re-adding references we'd have to carry around what references to re-add when the
  -- lifted part is finished.
  ALift   : ∀ {A ys post xs} → (inc : ys ⊆ xs) →
    ∞ (ActorM IS A ys post) →
    ActorM IS A xs post
  -- Adds the reference to this actor to its available references.
  Self : ∀ {pre} → ActorM IS ⊤₁ pre (λ _ → IS ∷ pre)
--
-- ========== Helpers for ActorM ==========
--

-- coinduction helper for Value
return₁ : {A : Set (suc zero)} → ∀ {IS post} → (val : A) → ∞ (ActorM IS A (post val) post)
return₁ val = ♯ Value val

-- universe lifting for return₁
return : {A : Set} → ∀ {IS post} → (val : A) → ∞ (ActorM IS (Lift A) (post (lift val)) post)
return val = return₁ (lift val)

-- coinduction helper for spawn
spawn : ∀ {IS NewIS A pre postN} →
  ActorM NewIS A [] postN →
  ∞ (ActorM IS ⊤₁ pre λ _ → NewIS ∷ pre)
spawn newAct = ♯ Spawn newAct

-- coinduction helper and neater syntax for value sending
_![t:_]_ : ∀ {IS ToIS pre MT} →
  (canSendTo : ToIS ∈ pre) →
  (MT ∈ ToIS) →
  All (send-field-content pre) MT →
  ∞ (ActorM IS ⊤₁ pre (λ _ → pre))
canSendTo ![t: p ] fields = ♯ Send canSendTo (SendM p fields)

-- coinduction helper for Receive
receive : ∀ {IS pre} → ∞ (ActorM IS (Message IS) pre (add-references pre))
receive = ♯ Receive


⊠-of-values : List Set → InboxShape
⊠-of-values [] = []
⊠-of-values (x ∷ vs) = (ValueType x ∷ []) ∷ ⊠-of-values vs
\end{code}
