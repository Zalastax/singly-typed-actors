\begin{code}
module ActorMonad where
open import Membership using (_∈_ ; _⊆_ ; ⊆-refl ; Z ; S ; find-∈)

open import Data.List using (List ; [] ; _∷_ ; _++_)
open import Data.List.All using (All ; [] ; _∷_)
open import Data.Unit using (⊤ ; tt)

open import Coinduction using (∞ ; ♯_)
open import Level using (Lift ; lift ; suc ; zero)
\end{code}

An Actor is indexed by the shape of its inbox.

The shape dictates what types the messages sent to an actor can have,
 and thus also what types the messages being received by the actor can have.

The shape is constant over the actors whole life-time.
It would be nice to allow the shape to grow monotonically over time.

%<*InboxShape>
Our typing rules for communication are based on the idea that the most important
property of a message is that it can be understood by the receiver.
The type system will thus be used to limit what type a message sent to an inbox can have.
By limiting the types of messages sent to an inbox,
we can make sure that every message read from the inbox has a valid type.
In terms of \textcite{DBLP:conf/agere/KosterCM16}, this is the interface of the actor.

\AgdaTarget{MessageType}
\AgdaTarget{ValueType}
\AgdaTarget{ReferenceType}
\AgdaTarget{InboxShape}
\begin{code}
mutual
  data MessageField : Set₁ where
    ValueType : Set → MessageField
    ReferenceType : InboxShape → MessageField

  MessageType = List MessageField

  InboxShape = List MessageType
\end{code}

The \AgdaRef[ActorMonad]{InboxShape} is a variant type that details
all the messages that can be received from an inbox.
Every message sent to an actor will have exactly one of the types that is listed.
We can think of the \AgdaRef[ActorMonad]{InboxShape} as a set of types,
and every message coming paired with a proof that the message is a type from that set.
To know what type a message has you have to inspect the proof,
and the value or reference in the message will become accessible.
For those familiar with Haskell,
\AgdaRef[ActorMonad]{InboxShape} can be seen as a generalized Either type.

\AgdaRef[ActorMonad]{MessageType} also uses a list as its underlying data structure,
but for a rather different purpose.
\AgdaRef[ActorMonad]{MessageType} is the type of a single message,
and every element in the list represents a single field in a record.
\AgdaRef[ActorMonad]{MessageType} can thus be seen as a generalized tuple type.

The fields in \AgdaRef[ActorMonad]{MessageType} are either a value type or a reference type.
A value type is any type from Agda's lowest set universe.
Typical examples are \AgdaRef[Examples/Types]{Bool}, \AgdaRef[Examples/Types]{ℕ},
or \AgdaRef[Examples/Types]{⊤}.
We limit the types to the lowest set universe since it's not clear how values of
higher universes could be serialized and sent over the wire in a distributed setting,
since that would entail serializing the types themselves.
Unfortunately, the lowest set universe also contain functions that have their types fully specified:
\AgdaCatch{Examples/Types}{unfortunate}
We could of course add further constraints on the types,
e.g. that every value has to be serializable,
but due to its insignificance to the calculus we have opted not to.

A reference is directly tied to an underlying inbox and
what inbox that is can not change during its lifetime.
The type of a reference specifies what type a message sent via the reference can have,
and is used to uphold the guarantee that every message in the inbox
can be understood by the receiver.
The guarantee is automatically enforced since sending an actor a message
of the wrong type will raise a compilation error.
By using type-parameterized actor references,
the receiver does not need to worry about unexpected messages,
while senders can be sure that messages will be understood.
Typically, the reference type should be the smallest set of types
that will be sent using that reference.
%</InboxShape>

%<*InboxShapeSubtype>
The Interface Segregation Principle (ISP) is a design principle that states
that no client should be forced to depend on methods it does not use \parencite{martin2002agile}.
When clients depend upon objects which contain methods used only by other clients,
this can lead to fragile code \parencite{martin2002agile}.
In particular, if a client depends on an interface that contains
methods that the client does not use but others do,
that client will be affected by changes that those other clients
force on the interface \parencite{martin2002agile}.
This idea has also been addressed in the context of actor systems
where \textcite{DBLP:conf/ecoop/HeWT14} uses the term \emph{type pollution problem}
to describe the issue of actor interfaces being too fat.

Just as the advice of ISP is to break each class into granular interfaces,
the advice of \textcite{DBLP:conf/ecoop/HeWT14} is
to break the type of inboxes into granular subtypes.
What the subtype relation means is that given two inboxes $A$ and $B$,
if $A <: B$, then every message in $A$ is also a valid message in $B$.
Since we model \AgdaRef[ActorMonad]{InboxShape} as a set,
our subtype relation can be taken to just be the subset relation.
The drawback of using subsets is that recursive subtypes are not captured,
but we deem it good enough for our purposes and simple to work with.

\todo{Create an example of the type-pollution problem solved}
\begin{code}
_<:_ = _⊆_ {A = MessageType}
\end{code}
%</InboxShapeSubtype>

%<*ReferenceSubtype>
For inboxes the subtype relation $A <: B$ says that
every message in $A$ is also a valid message in $B$.
It should therefore be possible to downcast a reference of type $B$ to a reference of type $A$,
since every message sent to a reference of type $A$ will be a valid message in $B$.
As we can see, the subtype relation for references is reversed,
and is thus contravariant in its argument \parencite{DBLP:conf/ecoop/HeWT14}.
The notion of a subtype for references is important to implement
the pattern of sending a command together with what reference to reply to,
since different actors receiving the reply will have a different \AgdaRef[ActorMonad]{InboxShape}.
This pattern, together with a filtering receive construct,
can be used to implement synchronous calls \parencite{ericsson_gen}.
%</ReferenceSubtype>
%<*ActorPrecondition>
It is crucial that actor references are completely unforgeable if type safety is to be preserved.
If an actor is allowed to manufacture references on their own,
every guarantee we have about message types becomes invalid and unusable.
If either the name or the type of a reference can be controlled in user space,
then it becomes possible to create references to inboxes that are incompatible
and thus possible to send messages that will not be understood by the received.
In an informal setting we could simply have hidden the constructor of actor references,
i.e. by moving it to an internal module or marking it as abstract.
That tactic is simple and pragmatic, but does not work in a formal setting like Agda.
This posed a difficult problem in our implementation
since we realized that we would need to make a major diversion from how
references are handled by \textcite{DBLP:conf/ecoop/FowlerLW17}.

When \textcite{DBLP:conf/ecoop/FowlerLW17} type terms,
values and references are treated the same way.
Since our model is an embedding in Agda,
this would mean that both references and values are normal Agda terms.
Initially we tried to follow this route by modelling references as a name tagged with a type.
\AgdaCatch{Examples/Types}{ActorRef}
One quickly realizes that this data-type is easily forged and, as said,
hiding the constructor is not a good enough option.
We also realized that it would not be possible to maintain any proofs of references being valid
if we went this route, a problem related to how we incorporate Agda functions in the syntax.
The solution that seemed to fit best in the setting of Agda
is to treat references separately from values.
This is because we need to maintain proofs about references being valid,
while values are only restricted under Agda's usual typing rules.

To guarantee that references are valid we do type checking of references manually.


\begin{code}
ReferenceTypes = List InboxShape

_⊢_ : ReferenceTypes → InboxShape → Set₁
Γ ⊢ T = T ∈ Γ

\end{code}

%</ActorPrecondition>


To formalize the notion of a reference that can be sent in a message in place of a less demanding type,
we create a variant of the \AgdaRef[ActorMonad]{_is-reference-in_} property.
The new property states that \AgdaSymbol{Fw} is a contravariant subtype to one of the references in \AgdaSymbol{S}.
An actor with \AgdaRef[ActorMonad]{InboxShape} \AgdaSymbol{S} should thus be able to receive a message containing a reference of type \AgdaSymbol{Fw}
and use it as if it was a reference of the type it wanted.

\AgdaTarget{ReferenceTypes}
\begin{code}
record compatible-reference (Γ : ReferenceTypes) (requested : InboxShape) : Set₁ where
  constructor [_]>:_
  field
    {actual} : InboxShape
    actual-is-sendable : Γ ⊢ T actual
    actual-handles-requested : requested <: actual

\end{code}
%<*Messages>
\begin{code}

-- We can create a value message for an inbox of shape S,
-- if the type of the value is a value type for S.
-- data ValueMessage (S : InboxShape) : Set₁ where
--  Value : ∀ {A} → A is-value-in S → A → ValueMessage S

-- We can create a reference message for an inbox of shape S,
-- if the type of the reference is a reference type for S.
--
-- When a reference message is received, the actors capabilities will increase,
-- allowing the actor to send messages to the actor referenced by the message.
--
-- A reference message can be created without having a valid reference in the current context.
-- It is the constructors of ActorM (more specifically SendReference) that limits the sending
-- of references to only those that are valid in the current context.
--
-- We index ReferenceMessage by both the reference type and the receiver's inbox.
-- data ReferenceMessage (S Fw : InboxShape) : Set₁ where
--  Reference : Fw is->:-reference-in S → ReferenceMessage S Fw

-- A Message is either a value or a reference.
--
-- We could just have wrapped ValueMessage and ReferenceMessage,
-- but that makes for a noisier experience when pattern matching in application code.

send-field-content : ReferenceTypes → MessageField → Set₁
send-field-content pre (ValueType A) = Lift A
send-field-content pre (ReferenceType requested) = compatible-reference pre requested


data SendMessage (To : InboxShape) (pre : ReferenceTypes) : Set₁ where
  SendM : {MT : MessageType} → MT ∈ To → All (send-field-content pre) MT → SendMessage To pre

receive-field-content : MessageField → Set
receive-field-content (ValueType A) = A
receive-field-content (ReferenceType Fw) = ⊤

data Message (To : InboxShape) : Set₁ where
  Msg : {MT : MessageType} → MT ∈ To → All receive-field-content MT → Message To

\end{code}
%</Messages>
\begin{code}

-- Simple lifting of ⊤ to reduce noise when the monad returns ⊤
⊤₁ : Set₁
⊤₁ = Lift ⊤

extract-references : MessageType → ReferenceTypes
extract-references [] = []
extract-references (ValueType x ∷ mt) = extract-references mt
extract-references (ReferenceType T ∷ mt) = T ∷ extract-references mt

-- When a message is received, we increase our capabilities iff the message is a reference.
add-references : ∀ {To} → ReferenceTypes → Message To → ReferenceTypes
add-references {To} pre (Msg {MT} x x₁) = extract-references MT ++ pre


infixl 1 _>>=_

-- An Actor is modeled as a monad.
--
-- It is indexed by the shape of its inbox, which can't change over the course of its life-time.
--
--
-- 'A' is the return value of the monad.
--
-- 'pre' is the precondition on the list of references that are available.
-- The precondition is what limits an actor to only being able to send messages
-- to actors that it has a reference to.
-- Sending a message is done by indexing into 'es',
-- thereby proving that the actor has a reference to the actor
-- that it's sending the message to.
--
-- 'post' is the postcondition on the list of references.
-- The postcondition sometimes depends on what happens during runtime,
-- and is thus modelled as a function on 'A'.
-- 'post' is what enables receive to have the right type.
data ActorM (IS : InboxShape) : (A : Set₁) →
              (pre : ReferenceTypes) →
              (post : A → ReferenceTypes) →
              Set₂ where
  -- Value is also known as return.
  -- The precondition is the same as the assignment axiom schema in Hoare logic.
  Value : ∀ {A post} → (val : A) → ActorM IS A (post val) post
  -- Bind / composition
  -- This is the same as the rule of composition in Hoare logic.
  -- post₁ is the midcondition.
  _>>=_ : ∀ {A B pre post₁ post₂} → (m : ∞ (ActorM IS A pre post₁)) →
          (f : (x : A) → ∞ (ActorM IS B (post₁ x) (post₂))) →
          ActorM IS B pre post₂
  -- Spawn a new actor.
  -- The spawned actor does not know any references.
  -- The reference to the spawned actor is added to the parent actor.
  Spawn : {NewIS : InboxShape} → {A : Set₁} → ∀ {pre postN} →
          ActorM NewIS A [] postN →
          ActorM IS ⊤₁ pre λ _ → NewIS ∷ pre
  -- Send a value to an actor.
  -- A value can only be sent to an actor if a reference to it is
  -- available in the precondition.
  -- ValueMessage is indexed by the shape of the inbox we're sending to,
  -- which makes sure that it's not possible to send values of the wrong type.
  Send : ∀ {pre} → {ToIS : InboxShape} →
    (canSendTo : pre ⊢ ToIS) →
    (msg : SendMessage ToIS pre) →
    ActorM IS ⊤₁ pre (λ _ → pre)
  -- Send a reference to an actor.
  -- A reference can only be sent to an actor if a reference to it is
  -- available in the precondition.
  -- The reference being sent also has to be available in the precondition.
  -- ReferenceMessage is indexed by the shape of both the shape of the forwarded
  -- reference and the shape of the receiving inbox.
  -- SendReference : ∀ {pre} → {ToIS FwIS : InboxShape} →
  --  (canSendTo : ToIS ∈ pre) →
  --  (canForward : FwIS ∈ pre) →
  --  (msg : ReferenceMessage ToIS FwIS) →
  --  ActorM IS ⊤₁ pre (λ _ → pre)
  -- Receive a message.
  -- When receiving a message, the postcondition depends on whether the message
  -- is a value or a reference.
  -- If the message is a value, the postcondition is the same as the precondition.
  -- If the message is a reference, the postcondition is the reference cons'ed to the precondition.
  -- If a receive is encountered when there are no messages in the actor's inbox,
  -- then the actor is moved to the 'blocked queue'.
  -- Sending a message to a blocked actor will move the actor from the 'blocked queue' back to the
  -- active actors.
  Receive : ∀ {pre} → ActorM IS (Message IS) pre (add-references pre)
  -- Lift let's you call a sub-program that needs less references than what is currently available.
  -- To allow that a lifted program increases the available references,
  -- the postcondition of the resulting actor is the same as the postcondition of the lifted program.¨
  -- We'd like there to be a way of re-adding the forgotten references, but that's easy to implement.
  -- To implement re-adding references we'd have to carry around what references to re-add when the
  -- lifted part is finished.
  ALift   : ∀ {A ys post xs} → (inc : ys ⊆ xs) →
    ∞ (ActorM IS A ys post) →
    ActorM IS A xs post
  -- Adds the reference to this actor to its available references.
  Self : ∀ {pre} → ActorM IS ⊤₁ pre (λ _ → IS ∷ pre)
--
-- ========== Helpers for ActorM ==========
--

-- coinduction helper for Value
return₁ : {A : Set (suc zero)} → ∀ {IS post} → (val : A) → ∞ (ActorM IS A (post val) post)
return₁ val = ♯ Value val

-- universe lifting for return₁
return : {A : Set} → ∀ {IS post} → (val : A) → ∞ (ActorM IS (Lift A) (post (lift val)) post)
return val = return₁ (lift val)

-- coinduction helper for spawn
spawn : ∀ {IS NewIS A pre postN} →
  ActorM NewIS A [] postN →
  ∞ (ActorM IS ⊤₁ pre λ _ → NewIS ∷ pre)
spawn newAct = ♯ Spawn newAct

-- coinduction helper and neater syntax for value sending
_![t:_]_ : ∀ {IS ToIS pre MT} →
  (canSendTo : ToIS ∈ pre) →
  (MT ∈ ToIS) →
  All (send-field-content pre) MT →
  ∞ (ActorM IS ⊤₁ pre (λ _ → pre))
canSendTo ![t: p ] fields = ♯ Send canSendTo (SendM p fields)

-- coinduction helper for Receive
receive : ∀ {IS pre} → ∞ (ActorM IS (Message IS) pre (add-references pre))
receive = ♯ Receive


⊠-of-values : List Set → InboxShape
⊠-of-values [] = []
⊠-of-values (x ∷ vs) = (ValueType x ∷ []) ∷ ⊠-of-values vs
\end{code}
