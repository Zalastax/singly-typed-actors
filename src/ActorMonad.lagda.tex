\begin{code}
module ActorMonad where
open import Membership using (_∈_ ; _⊆_ ; ⊆-refl ; Z ; S ; find-∈)

open import Data.List using (List ; [] ; _∷_ ; _++_)
open import Data.List.All using (All ; [] ; _∷_)
open import Data.Unit using (⊤ ; tt)

open import Level using (Lift ; lift ; suc ; zero)
open import Size using (Size ; Size<_ ; ↑_)
\end{code}

An Actor is indexed by the shape of its inbox.

The shape dictates what types the messages sent to an actor can have,
 and thus also what types the messages being received by the actor can have.

The shape is constant over the actors whole life-time.
It would be nice to allow the shape to grow monotonically over time.

%<*InboxShape>
The typing rules for communication in \ourlang are based on the idea that a very important
property of a message is that it can be understood by the receiver.
The type system will thus be used to limit what type a message sent to an inbox can have.
By limiting the types of messages sent to an inbox,
we can make sure that every message read from the inbox has a valid type.
In terms of \textcite{DBLP:conf/agere/KosterCM16}, this is the interface of the actor.

\AgdaTarget{MessageType}
\AgdaTarget{ValueType}
\AgdaTarget{ReferenceType}
\AgdaTarget{InboxShape}
\begin{code}
mutual
  data MessageField : Set₁ where
    ValueType : Set → MessageField
    ReferenceType : InboxShape → MessageField

  MessageType = List MessageField

  InboxShape = List MessageType
\end{code}

We define the type of an actor's inbox as an algebraic data-type with sums
(\AgdaRef[ActorMonad]{InboxShape}) of products (\AgdaRef[ActorMonad]{MessageType}).
The \AgdaRef[ActorMonad]{InboxShape} is a variant type that details
all the messages that can be received from an inbox.
Every message sent to an actor will have exactly one of the types that is listed,
which we communicate as a tag attached to the message (see section \ref{sec:messages}).
We can think of the \AgdaRef[ActorMonad]{InboxShape} as a set of types,
and every message coming paired with a proof that the message is a type from that set.
To know what type a message has you have to inspect the proof,
and the fields of the message will become accessible.

\AgdaRef[ActorMonad]{MessageType} also uses a list as its underlying data structure,
but for a rather different purpose.
\AgdaRef[ActorMonad]{MessageType} is the type of a single message,
and every element in the list represents a single field in a record.
\AgdaRef[ActorMonad]{MessageType} should thus be seen as a product type,
similar to Haskell's tuples.

The fields in \AgdaRef[ActorMonad]{MessageType} are combinations of value types and reference types.
A value type is any type from Agda's lowest set universe.
Typical examples are \AgdaRef[Examples/Types]{Bool}, \AgdaRef[Examples/Types]{ℕ},
or \AgdaRef[Examples/Types]{⊤}.
We limit the types to the lowest set universe as a sort of approximation of serializable values.
It would be possible to further constrain the types to only those that are serializable,
but due to its insignificance to the calculus we have opted not to.
A future improvement would be to ensure that all communication can be serialized,
which most importantly involves developing a serialization solution for $\Spawn$.

A reference provides the capability to send messages to an actor's inbox, where receiving a message
containing a reference is one of the few ways to increase an actor's capabilities.
The type of a reference specifies what type a message sent via the reference can have,
and is used to uphold the guarantee that every message in the receiver's inbox is well-typed.
By using typed actor references, the receiver does not need to worry about unexpected messages,
while senders can be sure that messages will be understood.
Typically, the reference type of a field should be the smallest set of types
that will be sent using that reference.

Below we have created an instance of an \AgdaRef[ActorMonad]{InboxShape},
showcasing the important concepts.
\AgdaRef[Examples/Types]{TestInbox} is an inbox that can receive two kinds of messages:
messages containing a single boolean value,
and messages containing a special kind of reference together with a natural number.
The reference in the second kind of message can be sent two kinds of messages as well:
messages containing a single boolean value,
and messages containing a single string value.

\AgdaCatch{Examples/Types}{ExampleInbox}
%</InboxShape>

%<*InboxShapeSubtype>
The Interface Segregation Principle (ISP) is a design principle that states
that no client should be forced to depend on methods it does not use \parencite{martin2002agile}.
\textcite{martin2002agile} claims that when clients depend upon objects which
contain methods used only by other clients, this can lead to fragile code.
In particular, if a client depends on an interface that contains
methods that the client does not use but others do,
that client will be affected by changes that those other clients force on the interface.
This idea has also been addressed in the context of actor systems
where \textcite{DBLP:conf/ecoop/HeWT14} uses the term \emph{type pollution problem}
to describe the issue of actor interfaces being too fat.

Just as the advice of ISP is to break each class into granular interfaces,
the advice of \textcite{DBLP:conf/ecoop/HeWT14} is
to break the type of inboxes into granular subtypes.
Subtyping of inboxes means that given two inboxes $A$ and $B$,
if $A <: B$, then every message in $A$ is also a valid message in $B$.
Since we model \AgdaRef[ActorMonad]{InboxShape} as a set,
the subtype relation can be taken to just be the subset relation.
The drawback of using subsets is that recursive subtypes are not captured,
but we deem it good enough for our purposes and simple to work with.

\todo{Create an example of the type-pollution problem solved}
\begin{code}
_<:_ = _⊆_ {A = MessageType}
\end{code}
%</InboxShapeSubtype>

%<*ActorPrecondition>
It is crucial that actor references are completely unforgeable if type safety is to be preserved.
If an actor is allowed to manufacture references on their own,
every guarantee we have about message types becomes invalid and unusable.
Allowing either the name or the type of a reference to be controlled in user space
makes it possible to create a reference to an inbox that is incompatible with the underlying inbox,
making it possible to send messages that will not be understood by the receiver.

In other settings we could simply have hidden the constructor of actor references,
i.e. by moving it to an internal module or marking it as abstract.
That tactic is simple and pragmatic,
but does not work in a formal setting like Agda without using postulates.
This posed a difficult problem in our implementation
since we realized that we would need to make a major diversion from how
references are handled by \textcite{DBLP:conf/ecoop/FowlerLW17}.

When \textcite{DBLP:conf/ecoop/FowlerLW17} type terms,
values and references are treated the same way.
Since our model is an embedding in Agda,
this would mean that both references and values are normal Agda terms.
Initially we tried to follow this route by modelling references as a name tagged with a type.
\AgdaCatch{Examples/Types}{ActorRef}
One quickly realizes that this data-type is easily forged and, as said,
hiding the constructor is not a good enough option.
We also realized that it would not be possible to maintain any proofs of references being valid
if we went this route, a problem related to how we incorporate Agda functions in the syntax.
The solution that seemed to fit best in the setting of Agda
is to treat references separately from values.
Values are kept as normal Agda terms, only restricted under Agda's usual typing rules.
References, on the other hand, are treated as variables that are maintained explicitly in the model.
Maintaining the references manually in the model is enough for guaranteeing that references
are valid, type correct, and unforgeable.

We type check references just how one would type check variables in any lambda calculus,
\ie by maintaining a variable typing context.
This is commonly done by associating unique variable names to types.
Variable names makes expressions easy to understand for humans,
but pose two annoying problems: α-renaming and α-equivalence.
α-equivalence is a form of equivalence that captures the intuition that the particular choice of
a bound variable name does not usually matter \parencite{turbak2008design}.
Renaming the variables of an expression in a way that preserves α-equivalence
is called α-renaming \parencite{turbak2008design}.
α-renaming is a part of the general concept of substitution,
the operation of replacing free occurances of a varibale with an expression.
The role of α-renaming in substituion is to avoid accidental variable name captures by renaming
variables so that substitution does not change the meaning of functions \parencite{turbak2008design}.

In order to avoid the problem of α-equivalence and α-renaming,
a common formalization technique is the use of de Bruijn indices
to represent variable binders \parencite{DBLP:journals/entcs/BerghoferU07}.
A de Bruijn index is a natural number that represents an occurance of a variable in a λ-term,
and denotes the number of binders that are in scope between that occurance
and its corresponding binder.
Following are some examples comparing a λ-calculus with names
and a λ-calculus using de Bruijn indices.

\begin{table}[htbp]
\centering
\begin{tabular}{ll}
Named                                 & de Bruijn                 \\
$ λ\ x → x $                          & $ λ\ 1 $                  \\
$ λ\ x → λ\ y → x $                   & $ λ\ λ\ 2 $               \\
$ λ\ x → λ\ y → λ\ z → x\ z\ (y\ z) $ & $ λ\ λ\ λ\ 3\ 1\ (2\ 1) $ \\
\end{tabular}
\end{table}

What makes de Bruijn indices easy to work with in Agda is that it lets us manage
the variable typing context as a list of types, with variables / de Bruijn indices being
indices into that list.
We choose to represent the indices as the membership proposition
in order to make the de Bruijn indices correct by construction.
This let's us define the type judgement $Γ ⊢ T$ as:

\AgdaCatch{Membership}{ElementIn}
\AgdaTarget{ReferenceTypes}
\begin{code}
ReferenceTypes = List InboxShape
TypingContext = ReferenceTypes

_⊢_ : TypingContext → InboxShape → Set₁
Γ ⊢ T = T ∈ Γ

\end{code}
%</ActorPrecondition>

%<*ReferenceSubtype>
For inboxes the subtype relation $A <: B$ says that
every message in $A$ is also a valid message in $B$.
It should therefore be possible to downcast a reference of type $B$ to a reference of type $A$,
since every message sent to a reference of type $A$ will be a valid message in $B$.
We can see that the subtype relation for references is reversed,
and is thus contravariant in its argument \parencite{DBLP:conf/ecoop/HeWT14}.
We capture this property in a special version of the reference typing judgement,
where $Γ ⊢>: T$ says that T is a subtype of some type in Γ.

\begin{code}
record _⊢>:_ (Γ : TypingContext) (requested : InboxShape) : Set₁ where
  constructor [_]>:_
  field
    {actual} : InboxShape
    actual-is-sendable : Γ ⊢ actual
    actual-handles-requested : requested <: actual

\end{code}

The notion of a subtype for references is important to implement
the pattern of sending a command together with what reference to reply to,
since different actors receiving the reply will have a different \AgdaRef[ActorMonad]{InboxShape}.
This pattern, together with a selective receive construct,
can be used to implement synchronous calls \parencite{ericsson_gen}.
%</ReferenceSubtype>

%<*Messages>
Messages in \ourlang are made up of a tag, indicating the type of the message,
and instatiations of the fields in that message type.
We have made the unusual decision to give outgoing and incoming messages slightly different shapes.
This choice is purely for ease of implementation and does not affect the power of the model.

An outgoing message is made of two parts: the tag that indicates which type of message it is
and instantiations of every field of the type selected by the tag.
We index the type of a message by the type of inbox it is being sent to and incidentally by the
variable typing context.
Selecting which type variant this message has is done by indexing
into the \AgdaRef[ActorMonad]{InboxShape}, using the $∈$ property.
The rest of the message is made up of instantiations of the fields
from the selected \AgdaRef[ActorMonad]{MessageType}.
For values, the instantiation of a field is simply an Agda term of the type specified by the field.
For references, the instantiation is not a simple Agda term,
but rather a variable in the reference context.
The type of the selected reference variable must be compatible with the type that the receiver expects,
\ie the types have to have the correct subtype relation.

\begin{code}

send-field-content : TypingContext → MessageField → Set₁
send-field-content Γ (ValueType A) = Lift A
send-field-content Γ (ReferenceType requested) = Γ ⊢>: requested

data SendMessage (To : InboxShape) (Γ : TypingContext) : Set₁ where
  SendM : {MT : MessageType} →
          MT ∈ To →
          All (send-field-content Γ) MT →
          SendMessage To Γ
\end{code}

Incoming messages differ from outgoing messages in the instantiation of reference fields.
One would expect the content of a reference field to be some representation of a reference,
\eg an index into the variable context.
Instead we find the unit type, which has no computational content at all.
The answer to this puzzle lies in that receiving a message will have the side-effect of
adding the references from every reference field to the variable context.
We will see in section \ref{sec:actorm} that the shape of the variable typing context is maintained
in the type of the monad, making it easy to create indices into the variable context
without making them a part of the message.
It would be possible to make the reference field content be an indicex into the variable context,
but it would make the model slightly more complicated without making it more powerful.


\begin{code}

receive-field-content : MessageField → Set
receive-field-content (ValueType A) = A
receive-field-content (ReferenceType Fw) = ⊤

data Message (To : InboxShape) : Set₁ where
  Msg : {MT : MessageType} →
        MT ∈ To →
        All receive-field-content MT →
        Message To

extract-references : MessageType → ReferenceTypes
extract-references [] = []
extract-references (ValueType x ∷ mt) = extract-references mt
extract-references (ReferenceType T ∷ mt) = T ∷ extract-references mt

add-references : ∀ {To} → TypingContext → Message To → TypingContext
add-references Γ (Msg {MT} x x₁) = extract-references MT ++ Γ
\end{code}
%</Messages>
\begin{code}
infixl 1 _∞>>=_ _>>=_ _∞>>_ _>>_
\end{code}
%<*LiftTop>
\AgdaTarget{⊤₁}
\begin{code}
⊤₁ : Set₁
⊤₁ = Lift ⊤
\end{code}
%</LiftTop>

%<*ActorMonad>
This thesis started out with the goal of formalizing the λ-calculus for actors that
\textcite{DBLP:conf/ecoop/FowlerLW17} call $λ_{act}$.
When investigating $λ_{act}$ we noticed that the language had a structure that made it suitable
for being directly embedded in Agda,
as opposed to the external λ-calculus we originally envisioned.
What we had found was that the processes of $λ_{act}$ were instances of the monad pattern.
Furthermore,
\textcite{DBLP:conf/ecoop/FowlerLW17} show that if the host language is sufficiently advanced
selective receive can be implemented as a library, in contrast to having it as a built in primitive.
This lead to us to implement \ourlang as an embedded DSL in the form of a monad.

The goal when translating $λ_{act}$ to an Agda embedding was to make the actors correct by construction,
and to make it possible to type-check each actor separately.
The pattern we found suitable is a monad parameterized by the type of the actor's
inbox (\AgdaRef[ActorMonad]{InboxShape}) and indexed by a reference variable context.
Following \textcite{DBLP:conf/ecoop/FowlerLW17}, the \AgdaRef[ActorMonad]{InboxShape} of an actor is
constant over its lifetime and should be likened with the type-and-effect system of $λ_{act}$.
Each actor has their own reference variable context and the way it changes over time
is kept track of in the style of the parameterized monad pattern,
capturing preconditions and postconditions in the type.

Actors are potentially infinite processes, making it suitable to model \ourlang using coinduction.
Following the lead of \textcite{DBLP:journals/corr/AbelC14},
we represent the monad \AgdaRef[ActorMonad]{ActorM} as a mutual definition of an inductive
datatype and a coinductive record.
The record \AgdaRef[ActorMonad]{∞ActorM} is a coalgebra that one interacts with by using its
single observation (copattern) \AgdaRef[ActorMonad]{force}.
\AgdaRef[ActorMonad]{force} gives us an element of the \AgdaRef[ActorMonad]{ActorM} datatype
on which we can pattern match to see which computation to perform next.

Both \AgdaRef[ActorMonad]{ActorM} and \AgdaRef[ActorMonad]{∞ActorM} are indexed by a size $i$.
The size is a lower bound on on the number of times we can iteratively \AgdaRef[ActorMonad]{force}
the computation,
but should primarily be seen as a means to establish productivity of recursive definitions.
When we actually simulate running actors,
we only care for \AgdaRef[ActorMonad]{ActorM} \AgdaPostulate{∞} \AgdaDatatype{A}
of infinite depth.

\AgdaTarget{ActorM}
\AgdaTarget{∞ActorM}
\AgdaTarget{force}
\begin{code}
data ActorM (i : Size) (IS : InboxShape) : (A : Set₁) →
              (pre : TypingContext) →
              (post : A → TypingContext) →
              Set₂

record ∞ActorM (i : Size) (IS : InboxShape) (A : Set₁)
               (pre : TypingContext)
               (post : A → TypingContext) :
               Set₂ where
  coinductive
  constructor delay_
  field force : ∀ {j : Size< i} → ActorM j IS A pre post

data ActorM (i : Size) (IS : InboxShape) where
\end{code}
%</ActorMonad>
%<*ActorMonadBindReturn>
Return and bind of the actor monad uses the invariants that are expected from any parameterized
monad, which is explained in section \ref{parameterized_monads}.
Bind chains together potentially infinite sub-computations,
and we can see that bind preserves the size (observation depth) $i$.
Agda implements a sort of subtyping for sizes,
so computations of different sizes can still be composed via bind.

We don't give the constructors \AgdaRef[ActorMonad]{Return} and \AgdaInductiveConstructor{∞>>=}
the names return and >>=,
since we want those names to refer to the type \AgdaRef[ActorMonad]{∞ActorM}.
Instead, the actual return and >>= are defined as a separate functions
that wrap \AgdaRef[ActorMonad]{Return} and \AgdaInductiveConstructor{∞>>=}.

\AgdaTarget{Return}
\begin{code}
  Return : ∀ {A post} → (val : A) → ActorM i IS A (post val) post
  _∞>>=_ : ∀ {A B pre mid post} → (m : ∞ActorM i IS A pre mid) →
    (f : (x : A) → ∞ActorM i IS B (mid x) (post)) →
    ActorM i IS B pre post
\end{code}
%</ActorMonadBindReturn>
%<*ActorMonadSpawn>
\AgdaRef[ActorMonad]{Spawn} creates a new actor and adds a reference to the spawned actor
to the spawning actor's variable context.
The spawned actor starts with both an empty inbox and an empty variable context.
\AgdaTarget{Spawn}
\begin{code}
  Spawn : {NewIS : InboxShape} → {A : Set₁} → ∀ {pre postN} →
    ActorM i NewIS A [] postN →
    ActorM i IS ⊤₁ pre λ _ → NewIS ∷ pre
\end{code}
%</ActorMonadSpawn>
%<*ActorMonadSend>
An actor can send messages to any actor it has a reference to.
It is not explicit in the monad what happens to a sent message, but we see in (SECTION)
that evaluating Send will append the message to the actor being referenced.
The reference variable might be a subtype to the underlying actor it references,
but this fact is completely opaque to the \AgdaRef[ActorMonad]{Send} construct.
The contents of the message is detailed in section \ref{sec:messages}.
Sending  a message does of course not affect the variable context,
which is captured in the postcondition being the same as the precondition.
\AgdaTarget{Send}
\begin{code}
  Send : ∀ {pre} → {ToIS : InboxShape} →
    (canSendTo : pre ⊢ ToIS) →
    (msg : SendMessage ToIS pre) →
    ActorM i IS ⊤₁ pre (λ _ → pre)
\end{code}
%</ActorMonadSend>
%<*ActorMonadReceive>
The \AgdaRef[ActorMonad]{Receive} construct is an operation that optimistically tries to
retrieve a message from the actor's inbox.
Messages are retrieved in the order they are added to the inbox,
and in the case of an empty inbox the actor is paused indefinitely.
As discussed in section \ref{sec:messages}, every reference in the received message will be added
to the actor's variable context.
\AgdaRef[ActorMonad]{Receive} is the only construct that have a postcondition that depends on
run-time behaviour, so a model where references are handled differently could allow for
actors to be implemented as non-parameterized monads.
\AgdaTarget{Receive}
\begin{code}
  Receive : ∀ {pre} → ActorM i IS (Message IS) pre (add-references pre)
\end{code}
%</ActorMonadReceive>
%<*ActorMonadSelf>
A key concept in Erlang-style actors is that actors can easily get a reference to themselves.
For example, in order to implement callbacks the initiating actor must include a reference
to themselves for the corresponding actor to reply to.
In \AgdaRef[ActorMonad]{ActorM}, this need is fulfilled by the \AgdaRef[ActorMonad]{Self} construct,
which adds a reference to the actor itself to the variable context.
\AgdaTarget{Self}
\begin{code}
  Self : ∀ {pre} → ActorM i IS ⊤₁ pre (λ _ → IS ∷ pre)
\end{code}
%</ActorMonadSelf>
%<*ActorMonadStrengthen>
The postconditions and preconditions that we get from our Hoare-style reasoning are sometimes not
quite what we want.
The invariants might be logically equivalent but have a different syntactic form.
For example, the variable context might be in the wrong order
or knows about more references than is expected.
We thus need a construct for reordering or forgetting about variables to
make subsequent invariants compatible.
What we chose to implement is similar to the strengthening rule in Hoare logic,
which affects the precondition of a statement.
The operation that \AgdaRef[ActorMonad]{Strengthen} performs is a re-ordering of the variables
in the variable context.
It does so by relating the precondition to the postcondition via a subset relation.
The subset relation supports re-ordering, duplication, and to forget variables,
making it powerful without sacrificing correctness.
\AgdaTarget{Strengthen}
\begin{code}
  Strengthen   : ∀ {ys xs} → (inc : ys ⊆ xs) →
    ActorM i IS ⊤₁ xs (λ _ → ys)
\end{code}
%</ActorMonadStrengthen>

%<*ActorMonadHelpers>
\begin{code}

--
-- ========== Helpers for ActorM ==========
--

open ∞ActorM public

-- coinduction helper for Value
return₁ : {A : Set (suc zero)} → ∀ {i IS post} → (val : A) →
          ∞ActorM i IS A (post val) post
return₁ val .force = Return val

-- universe lifting for return₁
return : {A : Set} → ∀ {i IS post} → (val : A) →
         ∞ActorM i IS (Lift A) (post (lift val)) post
return val = return₁ (lift val)

_>>=_ : ∀ {i IS A B pre mid post} → (m : ∞ActorM i IS A pre mid) →
  (f : (x : A) → ∞ActorM i IS B (mid x) (post)) →
  ∞ActorM i IS B pre post
(m >>= f) .force = m ∞>>= f

_∞>>_ : ∀ {i IS A B pre mid post} → (m : ∞ActorM i IS A pre (λ _ → mid)) →
  (n : ∞ActorM i IS B mid post) →
  ActorM i IS B pre post
m ∞>> n = m ∞>>= λ _ → n

[mid:_]_>>=_ : ∀ {i IS A B pre post} → ∀ mid →
  (m : ∞ActorM i IS A pre mid) →
  (f : (x : A) → ∞ActorM i IS B (mid x) (post)) →
  ∞ActorM i IS B pre post
[mid: mid ] m >>= f = _>>=_ {mid = mid} m f

_>>_ : ∀ {i IS A B pre mid post} → (m : ∞ActorM i IS A pre (λ _ → mid)) →
  (n : ∞ActorM i IS B mid post) →
  ∞ActorM i IS B pre post
(m >> n) .force = m ∞>> n

[mid:_]_>>_ : ∀ {i IS A B pre post} → ∀ mid →
  (m : ∞ActorM i IS A pre (λ _ → mid)) →
  (n : ∞ActorM i IS B mid (post)) →
  ∞ActorM i IS B pre post
[mid: mid ] m >> f = _>>_ {mid = mid} m f

-- coinduction helper for spawn
spawn : ∀ {i IS NewIS A pre postN} →
  ActorM i NewIS A [] postN →
  ∞ActorM (↑ i) IS ⊤₁ pre λ _ → NewIS ∷ pre
spawn newAct .force = Spawn newAct

-- spawn potentially infinite actors
spawn∞ : ∀ {i IS NewIS A pre postN} →
  ∞ActorM (↑ i) NewIS A [] postN →
  ∞ActorM (↑ i) IS ⊤₁ pre λ _ → NewIS ∷ pre
spawn∞ newAct = spawn (newAct .force)

-- coinduction helper and neater syntax for message sending
_![t:_]_ : ∀ {i IS ToIS pre MT} →
  (canSendTo : ToIS ∈ pre) →
  (MT ∈ ToIS) →
  All (send-field-content pre) MT →
  ∞ActorM (↑ i) IS ⊤₁ pre (λ _ → pre)
(canSendTo ![t: p ] fields) .force = Send canSendTo (SendM p fields)

-- coinduction helper for Receive
receive : ∀ {i IS pre} → ∞ActorM (↑ i) IS (Message IS) pre (add-references pre)
receive .force = Receive

self : ∀ {i IS pre} → ∞ActorM (↑ i) IS ⊤₁ pre (λ _ → IS ∷ pre)
self .force = Self

-- coinduction helper for Strengthen
strengthen : ∀ {i IS xs ys} → ys ⊆ xs → ∞ActorM (↑ i) IS ⊤₁ xs (λ _ → ys)
strengthen inc .force = Strengthen inc

⊠-of-values : List Set → InboxShape
⊠-of-values [] = []
⊠-of-values (x ∷ vs) = (ValueType x ∷ []) ∷ ⊠-of-values vs
\end{code}
%</ActorMonadHelpers>

